{"./":{"url":"./","title":"简介","keywords":"","body":"关于本书 或许你也有这样的一种感觉,回答一个问题时,吐了几个专业名词后,就不知道怎么拓展了; 或许你也做了几年开发,每天被各种业务需求淹没,感觉什么都会一些又感觉什么都不太会; 在梁宁的《产品思维30讲》中,提出过一种点线面体的思维模式。无论是面试问答还是职业规划,停下来想清楚个中的点线面体便有种豁然开朗。 本书名叫《Thinking in iOS》,写作思路便是从一个点开始思考,拓展出关联的其他点,最终呈现给你iOS开发的整体面貌。 "},"底层原理/compile.html":{"url":"底层原理/compile.html","title":"编译流程","keywords":"","body":"编译器 把一种编程语言(原始语言)转换为另一种编程语言(目标语言)的程序叫做编译器。 编译器一般由前端和后端两部分组成，前端负责词法分析、语法分析，生成中间代码。后端以中间代码作为输入，进行架构无关的优化，接着针对不同的架构生成不同的机器码。 前后端分离及通过中间代码(IR)协作的设计，使得前后端可以独立变化。新增一门语言只需要修改前端，而新增一个CPU架构只需要修改后端即可。 LLVM 什么是LLVM,他是一系列编译器组件和工具链的集合。引用维基百科的解释 LLVM包含一系列模块化的编译器组件和工具链，用来开发编译器前端和后端。现今LLVM已单纯成为一个品牌，适用于LLVM下的所有项目，包含LLVM中间码（LLVM IR）、LLVM调试工具、LLVM C++标准库等。 LLVM引发一些人来为许多语言开发新的编译器，其中一个最引发注意的就是Clang，它是一个新的编译器，同时支持C、Objective-C以及C++. 这里引出了我们的主角Clang。Object-c/c/c++编译器的前端就是Clang。以下是编译器编译的大致流程。 .m文件编译流程 本节将从代码层面跟踪一个文件的编译过程，文件名为main.c。代码如下: #include #define IPhoneXBarHeight 88 #define DEBUG 1 int main() { int barHeight = IPhoneXBarHeight; #ifdef DEBUG printf(\"hello debug\\n\"); #else printf(\"hello world\\n\"); #endif return 0; } 预处理 预处理阶段会进行头文件引入替换、宏替换、注释处理、条件编译等操作。 用clang进行预处理 xcrun clang -E main.c 结果如下: int main() { int barHeight = 88; printf(\"hello debug\\n\"); return 0; } stdio.h在预处理阶段会被替换成stido.h中的内容，这个过程是递归的，因为stdio.h也有可能引用了其他头文件。 在省略了几百行stdio.h的内容后，在末尾看到main函数预处理后只有3行。 IPhoneXBarHeight这个宏被替换成了具体的数字。 条件编译后，只留下了符合条件的printf(\"hello debug\\n\"); 词法分析 词法分析器读入预处理后的字符流，将他们组织成有意义的词素(最小的意义单位)序列。对于每个词素，词法分析器产生词法单元(token)作为输出。 xcrun clang -fmodules -fsyntax-only -Xclang -dump-tokens main.c 结果如下: annot_module_include '#include int 'int' [StartOfLine] Loc= identifier 'main' [LeadingSpace] Loc= l_paren '(' Loc= r_paren ')' Loc= l_brace '{' [LeadingSpace] Loc= int 'int' [StartOfLine] [LeadingSpace] Loc= identifier 'barHeight' [LeadingSpace] Loc= ... identifier 'barHeight' [LeadingSpace] Loc=表示 barHeight 这个变量名位于 main.c 第7行，左起第9个字符开始。这里的位置是基于原始代码的位置，而不是预处理后的。保存token在源文件中的位置方便后续clang分析的时候能够找出出错的原始位置。 语法分析 词法分析的Token流会被解析成一颗抽象语法树(AST). xcrun clang -fsyntax-only -Xclang -ast-dump main.c | open -f 部分结果如下: \u001b[0;34m`-\u001b[0m\u001b[0;1;32mFunctionDecl\u001b[0m\u001b[0;33m 0x7fbdbe8b5630\u001b[0m \u001b[0;33mline:5:5\u001b[0m\u001b[0;1;36m main\u001b[0m \u001b[0;32m'int ()'\u001b[0m \u001b[0;34m `-\u001b[0m\u001b[0;1;35mCompoundStmt\u001b[0m\u001b[0;33m 0x7fbdbe8b58f8\u001b[0m \u001b[0;34m |-\u001b[0m\u001b[0;1;35mDeclStmt\u001b[0m\u001b[0;33m 0x7fbdbe8b5768\u001b[0m \u001b[0;34m | `-\u001b[0m\u001b[0;1;32mVarDecl\u001b[0m\u001b[0;33m 0x7fbdbe8b56e8\u001b[0m \u001b[0;33mline:7:9\u001b[0m\u001b[0;1;36m barHeight\u001b[0m \u001b[0;32m'int'\u001b[0m cinit \u001b[0;34m | `-\u001b[0m\u001b[0;1;35mIntegerLiteral\u001b[0m\u001b[0;33m 0x7fbdbe8b5748\u001b[0m \u001b[0;32m'int'\u001b[0m\u001b[0;36m\u001b[0m\u001b[0;36m\u001b[0m\u001b[0;1;36m 88\u001b[0m 有了抽象语法树，clang就可以对这个树进行分析，找出代码中的错误，如类型不匹配，调用了未声明的方法等。 CodeGen CodeGen遍历语法树，生成LLVM IR代码。IR是前端的输出，后端的输入。 xcrun clang -S -emit-llvm main.c -o main.ll 部分结果如下: @.str = private unnamed_addr constant [13 x i8] c\"hello debug\\0A\\00\", align 1 ; Function Attrs: noinline nounwind optnone ssp uwtable define i32 @main() #0 { %1 = alloca i32, align 4 %2 = alloca i32, align 4 store i32 0, i32* %1, align 4 store i32 88, i32* %2, align 4 %3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0)) ret i32 0 } Objective-c代码会在这一步进行runtime的桥接:property合成，ARC处理等。 LLVM Optimizer LLVM对IR进行优化后，会针对不同架构生成不同的目标代码，最后以汇编代码的格式输出。 xcrun clang -S main.c -o main.s 部分代码如下: _main: ## @main .cfi_startproc ## %bb.0: pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 movq %rsp, %rbp .cfi_def_cfa_register %rbp subq $16, %rsp movl $0, -4(%rbp) movl $88, -8(%rbp) leaq L_.str(%rip), %rdi movb $0, %al callq _printf 汇编器 汇编器以汇编代码作为输入，将汇编代码转换为机器代码，最后输出.o目标文件 。 xcrun clang -fmodules -c main.c -o main.o 生成了main.o文件后，我们可以通过如下命令查看其中的符号。 xcrun nm -nm main.o 结果如下: (undefined) external _printf 0000000000000000 (__TEXT,__text) external _main 注意printf前的修饰。undefined表示在当前文件找不到符号。external表示这个符号是外部可以访问的。 链接 链接器把编译产生的.o文件和(a、tbd)文件一起生成mach-o可执行文件。可以看到,代码可以写在不同的文件里,每个文件都能够独立编成mach-o,最终链接器会将多个mach-o文件合并成一个，并创建一个全局符号表来记录所有已定义的和未定义的符号。 xcrun clang main.o -o main 执行后可以看到控制器会输出 \"hello debug\" 此时再查看可执行文件的符号表， (undefined) external _printf (from libSystem) (undefined) external dyld_stub_binder (from libSystem) 0000000100000000 (__TEXT,__text) [referenced dynamically] external __mh_execute_header 0000000100000f50 (__TEXT,__text) external _main from libSystem表示这个符号来自于libSystem，会在运行时动态绑定。 mach-o就是编译阶段的最终产物。需要注意的是，静态库会在这个阶段被链接进mach-o文件,动态库在运行时才会被链接。 "},"底层原理/lauch.html":{"url":"底层原理/lauch.html","title":"启动流程","keywords":"","body":"App的启动过程可以分为2个阶段: 第一阶段:premain,指点击app到执行main函数之前。 第二阶段:main,指main函数执行后到AppDelegate中didFinishLauchingWithOptions方法执行结束。 premain App启动时,系统先加载App的可执行文件(mach-o),从里面获得dyld(动态链接器)的路径,然后递归加载依赖的动态链接库,初始化runtime。当所有依赖库初始化完成后,runtime会对项目中所有类进行类结构初始化,然后调用所有的load方法。最后dyld返回main函数地址，main函数被调用。 动态链接库的加载步骤有如下4步: load dylibs image 读取库镜像文件 rebase/bind image objc setup initializer 以上步骤每一步的耗时都可以在Xcode中调试。具体配置为在Xcode的菜单中选择Project→Scheme→Edit Scheme...，然后找到 Run → Environment Variables →+，添加name为DYLD_PRINT_STATISTICS 值为1的环境变量。配置后启动时会打印类似如下结果: Total pre-main time: 980.77 milliseconds (100.0%) dylib loading time: 483.30 milliseconds (49.2%) rebase/binding time: 100.17 milliseconds (10.2%) ObjC setup time: 121.90 milliseconds (12.4%) initializer time: 275.18 milliseconds (28.0%) slowest intializers : libSystem.B.dylib : 7.67 milliseconds (0.7%) libglInterpose.dylib : 140.93 milliseconds (14.3%) libMTLInterpose.dylib : 58.22 milliseconds (5.9%) ai : 31.20 milliseconds (3.1%) load dylibs image 这一阶段dyld会分析应用依赖的dylib,找到其mach-o文件,打卡和读取这些文件并验证有效性,接着会找到代码签名注册到内核,最后dylib的每个segment调用mmap()。 通过一个app需要加载100到400个dylibs,但其中的系统库被优化,可以很快的加载。针对这一步骤的优化有: 减少非系统库的依赖 合并非系统库,苹果支持6个非系统库合并为1个 rebase/bind image 由于ASLR的存在,需要在这一步修正地址偏差。rebase将镜像读入内存,修正镜像内部的指针;bind 查询符号表,设置指向镜像外部的指针。针对这一步骤的优化有: 减少objc类数量,减少selector数量(整理删除无用代码) objc setup 这一步会进行Objc 运行时的初始处理，包括注册所有声明过的objc类,将分类插入到类的方法列表里,检查每个selector的唯一性。 initializer 这一步dyld会运行程序的初始化函数,调用每个objc类和分类的+load方法,调用c/c++中的构造函数和创建非基本类型的静态全局变量。该阶段执行完后,dyld开始调动main()函数。针对这一步骤的优化有: 少在类的+load方法里做事情,尽量把这些事情推迟到+initiailize. didFinishLaunchingWithOptions 在main()被调用后到didFinishLaunchingWithOptions结束这段时间,主要是执行启动项任务和完成首屏渲染。 启动项包括SDK初始化、统计上报、网络初始化等等,如果不加区分的一股脑堆在didFinishLaunchingWithOptions里,会极大影响启动速度。这一阶段可以将启动项根据所完成的任务进行分类,有些启动项是需要刚启动就执行的操作,如Crash监控、统计上报等,否则会导致信息收集的缺失;有些启动项需要在较早的时间节点完成,如网络初始化;有些可以被延迟执行,如自定义配置,支付SDK、地图SDK等。将启动项合理划分后,可以分别放入首页构建前、首页构建后、首页渲染完成等启动阶段，优化启动速度。 此外,使用纯代码方式而不是storyboard加载首页UI的方式,可以加快首屏渲染。 总结:启动速度优化,无非是让系统在启动期间少做一些事。当然我们得先清楚工程里做的哪些事是在启动期间做的、对启动速度的影响有多大，然后case by case地分析工程代码，通过放到子线程、延迟加载、懒加载等方式让系统在启动期间更轻松些。 "},"底层原理/view.html":{"url":"底层原理/view.html","title":"UI视图","keywords":"","body":"todo: 响应链和事件传递 "},"底层原理/object.html":{"url":"底层原理/object.html","title":"对象的本质","keywords":"","body":"runtime不只是一些C语言的API，更包括了一套完整的面向对象的数据结构。研究runtime，首先需要研究对象模型。 对象的本质 NSObject的底层实现 OC转c/c++ 为了探索本质,我们需要将oc的代码转化为对应的c代码。 待转化的oc代码，如下所示： #import @interface ZHAnimal : NSObject @property (nonatomic, assign) NSInteger age; @end @implementation ZHAnimal @end @interface ZHCat : ZHAnimal @property (nonatomic, assign) NSInteger legs; @end @implementation ZHCat @end int main(int argc, char * argv[]) { @autoreleasepool { } } 准备的事例代码使用了oc的类、属性及继承特性，以便我们探索这些特性的底层实现。 之后，我们使用如下命令进行转换。 xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o mainarm64.cpp 这个命令的意思是使用Clang编译器将main.m文件重写输出为mainarm64.cpp文件，指定的架构参数是arm64。 在mainarm64.cpp文件中，我们首先搜索\"ZHCat_IMPL {\",可以找到如下代码： struct ZHCat_IMPL { struct ZHAnimal_IMPL ZHAnimal_IVARS; NSInteger _legs; }; 除了自身的成员变量_legs,还能看到 ZHAnimal_IMPL 结构体类型的 ZHAnimal_IVARS 的结构体变量。 同理，我们搜索\"ZHAnimal_IMPL {\",可以找到如下代码： struct ZHAnimal_IMPL { struct NSObject_IMPL NSObject_IVARS; NSInteger _age; }; 这段代码逻辑和上面的一样。那么接着看NSObject。可以找到如下代码： struct objc_selector; struct objc_class; typedef struct objc_class *Class; struct NSObject_IMPL { Class isa; }; 到此为止，简单小结一下： NSObject的实现是struct,里面包含一个objc_class类型的结构体指针,名为isa. 存在继承关系的对象之间，子类的结构体中会包含父类的结构体成分，且父类的成分在前。 现在，所有的谜题都指向objc_class，我们当然想知道objc_class里都有些什么，但是在mainarm64.cpp中只有声明。下一节，我们将继续探索。 探寻objc_class 在objc4源码可以下载到开源代码，注意下载序号大的新版本。 在objc-runtime-new文件中，我们终于看到了objc_class的实现。代码如下: struct objc_class : objc_object { // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() { return bits.data(); } ... } struct objc_object { private: isa_t isa; public: // ISA() assumes this is NOT a tagged pointer object Class ISA(); // getIsa() allows this to be a tagged pointer object Class getIsa(); } typedef struct objc_object *id; 通过这段源码，我们可以看到，追踪到最后的数据结构是objc_object，里面有一个isa_t类型的isa成员。 oc中所有的对象都会包含一个isa_t类型的成员变量。objc_class类也是一个对象，通过继承于objc_object拿到了的isa_t结构类型的isa成员。 对象或者说实例对象，只有isa，用来找到对应的类对象。类对象才有superclass(父类指针)、cache(方法缓存)和bits(类数据信息)。（bits里包含了ivars成员变量列表、methods方法列表、protocals协议列表和properties属性列表等类信息） Class(objc_class)中的数据结构 isa_t isa数据结构的定义，摘录于objc4-750.1 union isa_t { isa_t() { } isa_t(uintptr_t value) : bits(value) { } Class cls; uintptr_t bits; #if defined(ISA_BITFIELD) struct { ISA_BITFIELD; // defined in isa.h }; #endif }; # define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 8 在arm64架构之前，isa就是一个普通的指针，存储着Class、Meta-Class对象地址 从arm64架构开始，isa成了一个union结构的共同体，并使用位域来存储更多的信息。 其含义如图所示:可以看到大多与内存管理相关 class_data_bits_t class_ro_t存储着类的原始信息，在运行时根据class_ro_t生成class_rw_t，并通过ro指针指回了class_ro_t. 以方法列表为例，假如Animal类有run方法，同时通过分类扩展了eat方法。那么，run方法首先位于class_ro_t中的baseMethodList中，在运行时，会加载所有分类，把分类中的方法和baseMethodList合并成methods，且分类中的方法在前。 class_rw_t中没有定义ivars的字段，在访问成员变量时，直接通过isa_t找到对应的objc_class,并通过class_ro_t的ivarlist做地址偏移，查找对应的对象内存。因此，内存布局在编译时就已经确定，runtime不能动态修改ivars，会破坏已有的内存布局。只能通过类似关联对象的方式重新开辟一开专门的内存空间。 method_t method_list_t数组中存储着method_t，method_t是对方法的封装。 struct method_t { SEL name;//方法名 const char *types;//编码，内含返回值类型、参数类型等信息 IMP imp; //本质为函数指针，存储函数实现的地址 }; cache_t 方法调用是在methods中通过receiver和SEL查找定位IMP的过程。如果一个方法被多次调用，通过缓存技术就能提高效率。 cache_t就是这样一个缓存，他通过散列表来缓存曾经调用过的方法，用以提高方法的查找速度。 struct cache_t { struct bucket_t *_buckets;//散列表 mask_t _mask;//散列表的长度 - 1 mask_t _occupied;//已经缓存的方法数量 } struct bucket_t { IMP _imp; cache_key_t _key;//SEL为key } // Class points to cache. SEL is key. Cache buckets store SEL+IMP. // Caches are never built in the dyld shared cache. static inline mask_t cache_hash(cache_key_t key, mask_t mask) { return (mask_t)(key & mask); } //objc-cache.mm 通过源码可以看到散列表的实现机制是：将SEL和长度进行&操作(类似取余)，得到的结果作为_buckets的下标。存取_buckets都可以通过下标直接查找。这种机制是非依次存放的，是一种空间换时间的思路。而当空间不够存放时，会进行扩容。此时因为key已经改变，会清空已缓存的数据，重新建索引。 对象间isa及superclass关系 "},"底层原理/category.html":{"url":"底层原理/category.html","title":"分类及关联对象","keywords":"","body":"Category数据结构 struct category_t { const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties; // Fields below this point are not always present on disk. struct property_list_t *_classProperties; ... }; 在objc-runtime-new.h中可以找到分类底层数据结构的定义。从数据结构上可以清楚的看到分类能干什么，不能干什么。它能存储实例方法、类方法、协议和属性，但没有对应的存储ivars的成员变量，故分类中不能添加成员变量。 Category的加载过程 Category和Extensiton很类似，两者的区别在于，Extensition在编译期就直接和原类编译在一起，Category是在运行时动态添加到原类中的。 应用程序启动流程如下: 应用程序启动后，系统读取可执行文件(Mach-O文件),从里面获取dyld的路径并加载dyld; runtime向dyld注册回调函数; 由dyld加载依赖库,生成对应的image对象，对这些image进行链接,并在image改变后调用回调函数; runtime接收dyld的函数回调，执行map_images、load_images等操作; 调用main()函数 在编译阶段，每个Category文件都是独立的，为category_t结构。在程序启动后的map_images阶段，会遍历category_t的二维数组，把所有独立的Category中对应的方法合并到对应的类和元类中。合并过程如下: 遍历某个类的所有分类，取出分类中的方法列表、属性列表等，合并成addedLists。并且最后参与编译的分类，最先加入; 原先的methodlists中的方法列表根据addedLists数量进行内存扩容; methodslists位置往后挪到addedListsCount个位置，前面的位置由addedLists填充，合并完毕; 需要注意的是第3步的挪动操作，因为方法查找是从前往后找的，找到即结束。这样的设计让分类中的方法总是比原类中的方法优先调用，也就是表现为分类中的同名方法会覆盖类中的原方法，但其实原方法还是在methodlist中的。 load和initialize方法 load方法调用在load_images阶段，main函数之前。load方法是拿到函数地址直接调用的，并没有走objc_msgSend方法，因此不会像分类一样存在方法覆盖的问题。此外，会优先调用类的load方法，并保证父类优先调用，之后调用分类的load方法，调用顺序为编译时的顺序。 initialize在类第一次接收到消息时调用。在lookup函数查找方法时，会判断是否需要初始化，如果需要，通过objcMsgSend调用initialize方法。由于走的是消息机制，会被分类覆盖。 关联对象 前文说过，动态添加成员变量会破坏已有的内存布局。在实际项目中，我们往往通过关联对象技术实现分类添加成员变量的效果。 在objc-references.mm文件中，我们可以看到关联对象的底层数据结构。 class AssociationsManager { // associative references: object pointer -> PtrPtrHashMap. static AssociationsHashMap *_map; }; class AssociationsHashMap : public unordered_map { }; class ObjectAssociationMap : public std::map { }; class ObjcAssociation { uintptr_t _policy; id _value; }; 当我们使用objc_setAssociatedObject设置关联对象时，究竟发现了什么呢？ 所有的关联对象都被被存在一个全局的hashMap中，由AssociationManager进行管理。hashMap的key是实例对象的内存地址，value是一个ObjectAssociationMap对象，保存了与这个实例对象关联的信息。 ObjectAssociationMap的key是关联时指定的属性的key，即传入的第二个参数。value是ObjcAssociation对象，存储关联时指定的value和policy. 可以看到，虽然数据结构构建的有些复杂，但在这种设计下，可以通过实例对象的内存地址和关联属性名作为key，高效的存储和查找。 "},"底层原理/kvc.html":{"url":"底层原理/kvc.html","title":"KVC&KVO","keywords":"","body":"KVC和KVO的底层实现机制都是isa-swizzing,通过runtime替换实例对象的isa指针为派生类来达到目的。 KVO KVO全称是Key-Value Observing，键值监听，可以用于监听某个对象属性值的改变，对应于观察者模式。 KVO实现机制: 使用runtime动态生成子类，并将实例对象的isa指针指向子类; 子类重写set方法，当值被改变时，依次调用willChangeValueForKey:、[super set]、didChangeValueForKey: didChangeValueForKey内部会调用obser的observerValueForKeyPath方法，让观察者收到改变的通知。 在某些场景下，如果我们有手动触发KVO的需求，比如用KVO监听数组，可以按第2步的调用顺序来模仿系统调用实现KVO的效果。 KVC KVO全称Key-Value Coding,键值编码,可以用于通过key名直接访问或修改对象的属性值，而不需要调用明确的存取方法。 setValue:forKey执行逻辑: 按照setKey:、_setKey:的顺序查找方法，如果找到、传值调用; 查看accessInstanceVariablesDirectly方法的返回值。如果返回NO,调用setValue:forUnderfinedKey并抛出异常。如果返回Yes,按照_key,_isKey,key,isKey顺序查找成员变量，如找到，直接赋值。如果没找到，同样调用setValue:forUnderfinedKey并抛出异常。 valueForKey:执行逻辑: 按照getKey、key、isKey、_key顺序查找方法，如果找到，直接调用。 查看accessInstanceVariablesDirectly方法的返回值，如果返回Yes,按照_key,_isKey,key,isKey顺序查找成员变量，如果找到，直接取值。否则，调用valueForUnderfinedKye:并抛出异常。 "},"底层原理/message.html":{"url":"底层原理/message.html","title":"消息机制","keywords":"","body":"消息机制 方法调用 //oc代码 int main(int argc, char * argv[]) { ZHAnimal *animal = [ZHAnimal new]; [animal run]; } //重写后的c++代码 int main(int argc, char * argv[]) { ZHAnimal *animal = objc_msgSend(objc_getClass(\"ZHAnimal\"), sel_registerName(\"new\")); objc_msgSend(animal, sel_registerName(\"run\")); } 可以看到，oc的方法调用，本质是objc_msgSend函数，故方法调用又叫发送消息。虽然run方法本身没有参数，但是转成objc_msgSend时会默认传入2个参数，消息接收者和方法选择器。这也是为什么我们在oc方法内可以直接使用self和_cmd这两个变量名的原因。 objc_msgSend(void /* id self, SEL op, ... */ ) objc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */ ) struct objc_super2 { id receiver; Class current_class; } 需要注意的是，当我们调用[super method]方法时,底层会转换为objc_msgSendSuper2函数的调用，接收struct objc_super2和SEL两个参数。其中receiver的值还是self，也就说，super调用的本质还是给self发送消息，只是在方法查找时会跳过self的Class而优先从superClass的方法列表中查找。 objc_msgSend的执行流程可分为消息发送、动态方法解析和消息转发3个阶段: 消息发送 判断receiver是否为空，若为空则直接返回; 根据receiver的isa找到receiverClass并在其缓存中查找方法,若找到，调用方法，结束查找。 从receierClass的class_rw_t中查找方法，若找到，调用方法，结束查找并将方法缓存到receiverClass的cache中。(即使调用的是父类的方法，也会缓存到receiverClass中) 根据reciverClass的super指针往上遍历，重复2，3查找流程。 还没找到，进入动态方法解析阶段。 动态方法解析 判断是否已经进行过动态解析，如果是，进入消息转发阶段。 调用 + (BOOL)resolveInstanceMethod:(SEL)sel 或 + (BOOL)resolveClassMethod:(SEL)sel。开发者可以在此动态添加方法实现 标记为已经进行过动态解析。 重新走消息发送流程。如果确实动态添加了方法实现，此时消息发送流程中能找到方法并缓存，如果没有添加，进入消息转发阶段。 消息转发 调用- (id)forwardingTargetForSelector:(SEL)aSelector方法来尝试确定能处理方法的其他对象。如果返回值不为空，效果类似于objc_msgSend(返回值,SEL)。若为空，进入下一环节。 调用- (NSMethodSignature *)methodSignatureForSelector:方法来确定SEL的方法签名。官方文档对此有如下描述: This method is used in situations where an NSInvocation object must be created, such as during message forwarding.可见主要是为了将消息调用封装成NSInvocation对象搜集方法签名信息。如果有返回值，进入下一环节，否则就会抛出UnRecognize selector的错误。 调用-/+ (void)forwardInvocation方法。NSInvocation对象包括了消息的所有元素：调用者、选择器、参数和返回值。因此拿到NSInvocation后可以自定义处理逻辑。至此，方法调用完毕。 待续... "},"底层原理/runloop.html":{"url":"底层原理/runloop.html","title":"runloop","keywords":"","body":"runLoop概念 runLoop简单来说就是一个do-while循环,内部一直处于\"接受消息->处理事件->休眠等待\"的循环中。如果是我们自己写的do-while循环，哪怕不处理事件，也会持续占用cpu资源。runLoop在休眠时几乎不会占用系统资源，在有消息到来时立刻被唤醒。 runLoop与线程 通常来说,一个线程一次只能执行一个任务,在执行完对应任务后就会退出， 每条线程都有唯一一个与之对应的RunLoop对象; RunLoop保存在一个全局的字典里，线程作为key，RunLoop作为value; 线程刚创建时并没有RunLoop对象，RunLoop会在第一次获取时创建，并保存在全局字典中。 runLoop数据结构 runLoop运行逻辑 通知observer,进入Loop; 如果有timers事件,通知Observer,即将处理timers; 如果有sources要处理的话，通过observer,即将处理sources 处理source0 如果当前是主线程的runloop,并且主线程有事，跳转到第9步; 通知observer,runloop即将进入休眠状态; 进入休眠状态，等待唤醒; 通知observer,runloop被唤醒 处理唤醒时收到的消息(处理timer、处理dispatchport、处理source1)。继续循环，跳回2; 通知observer，runloop即将退出; "},"底层原理/block.html":{"url":"底层原理/block.html","title":"block","keywords":"","body":"Block的本质 还是使用重写为C语言的方法，来探索底层实现。 源代码: int main(int argc, char * argv[]) { int age = 18; void (^ageBlock)(void) = ^{ NSLog(@\"年龄是%d岁\",age); }; ageBlock(); } 使用命令: xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o mainarm64.cpp 摘入.cpp文件中的关键代码如下: int main(int argc, char * argv[]) { int age = 18; void (*ageBlock)(void) = (&__main_block_impl_0( __main_block_func_0, &__main_block_desc_0_DATA, age) ); (ageBlock->FuncPtr)(ageBlock); } struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; int age; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age) { impl.isa = &_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr; }; static void __main_block_func_0(struct __main_block_impl_0 *__cself) { int age = __cself->age; // bound by copy NSLog((NSString *)&__NSConstantStringImpl__var_folders_8c_jf6slqz973v1dxj8z9g8z02w0000gn_T_main_f2862d_mi_0,age); } static struct __main_block_desc_0 { size_t reserved; size_t Block_size; } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)}; 在main函数看到，ageBlock通过main_block_impl_0的构造函数生成，参数分别为main_block_func_0（block内代码的封装）、__main_block_desc_0_DATA(Block描述信息)及age(被捕获的变量). 当我们调用block时，实质上是调用了封装的函数FuncPtr。 至此，关于Block的本质我们可以得出如下结论： Block本质是一个OC对象，内部有isa指针指向类对象。 Block会封装函数调用，并通过变量捕获封装函数调用的环境。 Block的类型 在上文中我们会看到类似 impl.isa = &_NSConcreteStackBlock; 的代码，Block既然是对象，我们就可以通过 [NSObject class] 或 object_getClass方法查看对应的类。 Block分为 NSGlobalBlock、NSStackBlock、NSMallocBlock3种类型，分别对应的内存地址为data区、栈区和堆区。 Block类型归纳如下: 在定义block类型属性时，我们往往使用copy关键字来修饰。在此处我们就能理解真正的用意。栈区变量的内存在离开作用域后就会被回收，为了不让block在使用前被回收，就需要将其从栈区拷贝到堆区内存。 例如如下代码:(MRC环境下) 加了copy后，block才能正常返回。在ARC下，编译器会帮我们自动处理。 typedef void(^block_t)(void); block_t getBlock(){ int age = 10; return [^{ NSLog(@\"age is %d\",age); } copy]; } 而如果我们block内不访问auto变量age,此时是GlobalBlock，位于data内存区，也是可以正常使用的。 Block的变量捕获 在第一节，我们分析重写后的c代码时，发现main_block_impl_0结构体中有变量age的定义，而且在main_block_impl_0的构造函数中会把外部的age通过值传递的方式给结构体的age赋值。 正因为是值传递的方式，所以我们只能读取使用，不能在block内部修改。 此时我们会想到，只要使用block修饰，就能在block内部修改了。那么就来看下block内部的具体实现。 还是第一章节的代码，加了__block 修饰age,重新重写为c++代码。 int main(int argc, char * argv[]) { __Block_byref_age_0 age = {0,&age, 0, sizeof(__Block_byref_age_0), 18}; void (*ageBlock)(void) = (&__main_block_impl_0( __main_block_func_0, &__main_block_desc_0_DATA, &age, 570425344)); (ageBlock)->FuncPtr)(ageBlock); } struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_age_0 *age; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_age_0 *_age, int flags=0) : age(_age->__forwarding) { impl.isa = &_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; struct __Block_byref_age_0 { void *__isa; __Block_byref_age_0 *__forwarding; int __flags; int __size; int age; }; 在main函数可以看到，使用了block修饰后，age变量变成了Block_byref_age_0对象类型。__Block_byref_age_0结构体内部也有isa指针，是个对象。 在main_block_impl_0的构造函数中，age对象以引用传递的方式传入block中。所以才有了block内部可以修改外部变量的效果。block的设计很好的屏蔽了内部实现细节。 Block的内存管理 在上一节中有一个细节，Block_byref_age_0结构体中有一个指向自己的forwarding指针。main_block_desc_0结构体中也多了copy和dispose两个函数。这些都和block的内存管理有关。具体如下: static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*); } struct __Block_byref_age_0 { void *__isa; __Block_byref_age_0 *__forwarding; int __flags; int __size; int age; }; 还是以__block int age;为例， 当block在栈上时，并不会对age变量产生强引用。 当block被copy到堆时，会调用内部的copy函数对__block变量产生强引用。 当block从堆中移除时，会调用内部的dispose函数，释放引用的变量。 static void __main_block_func_0(struct __main_block_impl_0 *__cself) { __Block_byref_age_0 *age = __cself->age; // bound by ref (age->__forwarding->age)++; NSLog((NSString *)&__NSConstantStringImpl__var_,(age->__forwarding->age)); } 在源码中，我们看到无论是读取age还是修改age，都是先通过自身的forwarding指针来访问和修改的，这是为什么呢？请看下图。 当一个block变量从栈上被复制到堆上时，栈上的结构体中的forwarding指针也会指向堆上的结构体。所以通过forwarding修改可以保证修改的都是堆上的结构体，main函数释放的时候，只是释放了栈上的东西。而所有的对局部变量的修改都早已经转移到堆上了。 "},"底层原理/memory.html":{"url":"底层原理/memory.html","title":"内存管理","keywords":"","body":""},"底层原理/thread.html":{"url":"底层原理/thread.html","title":"多线程","keywords":"","body":""},"底层原理/network.html":{"url":"底层原理/network.html","title":"网络","keywords":"","body":""},"系统架构/webview.html":{"url":"系统架构/webview.html","title":"WebView","keywords":"","body":""},"框架剖析/yytext.html":{"url":"框架剖析/yytext.html","title":"YYText","keywords":"","body":"todo 学习:https://mp.weixin.qq.com/s?__biz=MzA5NzMwODI0MA==&mid=2647762488&idx=1&sn=f77360d7754bb3b5ae8bb815e668e560&chksm=8887dd07bff054115e510cdf0047e1976049eca1562406ce42d7830eda34eb9892b7c77fb834&mpshare=1&scene=23&srcid=#rd "},"高性能/smooth.html":{"url":"高性能/smooth.html","title":"界面流畅的技巧","keywords":"","body":"todo: 学习 https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/ "},"面试题/interview.html":{"url":"面试题/interview.html","title":"面试题","keywords":"","body":"编译 简述一个.m文件的编译流程 预处理、词法语法分析生成抽象语法树、生成IR、汇编器生成.o目标文件、链接器生成mach-o可执行文件。 什么是符号表?在编译的哪个阶段产生的? 符号表是内存地址与函数名、文件名、行号的映射表。在链接阶段由链接器链接.o文件生成mach-o文件时记录生成。在调试时，可以通过符号表对crash的堆栈进行解析和还原。 启动 从点击app到看到首屏界面,经历了哪些阶段？ 主要是premain,main函数执行到首屏渲染完成3个阶段。premain又可细分为加载动态库、rebase/bind、Objc Setup和initialize4个阶段。 如何对app的启动速度进行优化? 减少合并动态库,尽量将load方法操作移动到initialize,剔除无用代码和类来提高premain阶段的速度;将启动项进行分阶段(首页构建前、首页构建后、渲染完成后)启动来提高启动项加载速度;使用代码而非xib构建页面来提高页面渲染速度。 "}}